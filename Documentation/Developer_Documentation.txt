BlackJackSim Python Project Developer Documentation

*** Casino Dealer hand play logic:

Count_Max = First ace counts 11, any remaining aces count 1
Count_Min = All aces count 1

Dealer must hit on 16 or less and stand on 17 or more. Dealer busts on greater than 21.

	If Count_Max <= 16, dealer must hit

	If Count_Max >= 17, dealer must stand

	If Count_Max > 21, that would be a bust, so then
		If Count_Min <= 16, dealer must hit
		if Count_Min >= 17, dealer must stand
		if Count_Min > 21, then dealer busts

	So, proceed to stand or bust using Count_Max,
		If stand, then done, and report out Count_Max as final hand count
		If bust, then proceed to stand or bust using Count_Min
			If stand, then done, and report out Count_Min as final hand count
			If bust, then report hand status as bust

Some resutls: Playing 100,000 hands with dealer and player both using this logic:
     Dealer Wins: 49056
     Player Wins: 41231
     Pushes: 9713
     Games Played: 100000
     Dealer % Wins: 49.056
     Player % Wins: 41.231
     Push %: 9.713



*** Holye Player hand play logic:

Always stand on 17

Always hit on 12 and under

For 13 - 16:
	Stand, if dealer shows 6 or lower
	Hit, if dealer shows 7 - 10, J, Q, K, or A

Count an Ace as 1 up to 17 (e.g., hit 2-4-A, counting it as 7)

So, trying to put all this together into a workflow...

	Test hands for each outcome are shown in [].

	Check Count_Max
		If Count_Max > 17 and <= 21, then stand [A 7] Test 1
		If Count_Max <= 17 or > 21, then check Count_Min [A 6]; [A 6 5] Test 2
	Check Count_Min
		If Count_Min > 21, then bust [A 6 5 K] Test 2
		If Count_Min >= 17, then stand [A 6 5 7] Test 3
		If Count_Min <= 12, then hit [A 6 5] Test 2, Test 3
		If Count_Min >=13 and <= 16, then [A 6 5 2] Test 4
			If dealer shows <= 6 (their one face up card), then stand (expecting dealer to hit and bust) [show = 6] Test 4
			If dealer shows 7 - 10, J, Q, K, A, then hit [A 6 5 2 3] [show = 7] Test 5
	After hitting, return to Check Count_Max

	Construct the following test cases
	Test 1 "Stand Max": Hand[A 7] Deck[...] show[...] Stand
	Test 2 "Bust Min": Hand[A 6] Deck[5 K] show[...] Hit Hit Bust
	Test 3 "stand min over seventeen": Hand[A 6] Deck[5 7] show[...] Hit Hit Stand
	Test 4 "stand min on show six or under": Hand[A 6] Deck[5 2] show[6] Hit Hit Stand
	Test 5 "stand min on show over six": Hand[A 6] Deck[5 2 3] show[7] Hit Hit Hit Stand

	Some results: Playing 100,000 hands with dealer using Casino logic and player both using this logic:
		 Dealer Wins: 47803
		 Player Wins: 43210
		 Pushes: 8987
		 Games Played: 100000
		 Dealer % Wins: 47.803
		 Player % Wins: 43.21
		 Push %: 8.987

	*** Thinking about how to not pass Hand()s and Deck()s into PlayStrategy().play() ...

	Hoyle player strategy requries the following "access" to the BlackJackSim: (Other current available strategies are same.)
		(1) Hand.hand_info() - Couls use new BlackJackSim.player_hand_info() and BlackJackSim.dealer_hand_info()
		The next two, (2) and (3), are used together...
		(2) Hand.add_cards()  - Could use BlackJackSim.draw_for_player()
		(3) Deck.draw() - Could use BlackJackSim.draw_for_player()
		(4) Use new BlackJackSim.get_dealer_show() to get the dealer's face up show card

	Landed on a solution of passing bound methods as arguments to the PlayStrategy().play() method.

	*** Thinking about how to implement splitting a player's hand when they are dealt a pair ***

	BlackJackSim.play_game(...) after implementing splitting proceeds as follows:
		Clear dealer, player, and split hands
		Deal to dealer as needed - 2 cards, or 1 if dealer_show is provided as argument, or 0 if dealer_down is also provided as argument
		Deal to player as needed - 0, 1, or 2 cards, depending on player_deal provided as argument
		Check player and dealer hands for BlackJack
			If one or both were dealt BlackJack, build GamePlayOutcome and return it
			If no BlackJacks were dealt, play on
				Test if player has a pair
					Enquire of player strategy if the pair should be split
						Transfer the 2nd card of the pair over to the split hand and draw another card into the split hand
						Draw a replacement card for the player hand
						Play the split hand using the player strategy
				Play the player hand using the player strategy
				Play the dealer hand using the dealer strategy
				Build GamePlayOutCome and return it

		Observations and thoughts:
			(1) Can't just recursively call BlackJackSim.play_game(), because the recursive call would operate on the same BlackJackSim.player_hand data member
				(a) Could we "recursively" create a new BlackJackSim object to play the second hand after the split?
				(b) NOTE: Tried this ... and then realized it has the problem of playing a second dealer hand
			(2) Have to be able to specify the dealer's whole deal, not just the show card.
				NOTE: It was realized that this is silly reasoning. The dealer only every has one hand to play.
			(3) Callers of BlackJackSim.play_game() are currently expecting to be returned a single GamePlayOutcome object, with the results of just one game.
				(a) Could we modify play_game() to return a list or a tuple of GamePlayOutcome objects? The fact that more than one was returned would indicate a split had occurred.
					(-) Existing callers must be modified to process the list or tuple correctly
					(+) Seems more "natural" and less "hack-like" and easier to understand than option (b)
					(+/-) All callers, to handle splits, must check if the list has more than one item in it or the tuple does and branch accordingly
					(+) A list or tuple could be processed by a for loop
					(+) A tuple is immutable, unlike a list
					NOTE: Tried the tuple return concept, but through it out when we switched over to following observation (5) for the solution.
				(b) Or, could we nest a second GamePlayOutcome object within the first, with the results of the second game of the split?
					(-) Seems a little "contrived" and "hack-like", and harder to grasp what is the intent
					(+) Existing callers function without modification, though would ignore the split game
					(-) No processing of this nesting with a loop
					(+/-) All callers, to handle splits, must include logic to see if their was a split (the nested object isn't None?) and branch accordingly
					NOTE: Never tried this. Used the solution hypothesized in observation (5) instead.
			(4) Can this get deeper ... that is, if the second card dealt to a split produces a pair, could the player split that?
				(*) I'm (guessing) this isn't part of the casino split rule
				(*) This should be a rate event
				(*) But, the simulation logic needs to be able to prevent this from happening, because in theory the recursion would just keep going
				NOTE: There is no concern with spliting a second time, under the circumstance that another pair is formed by dealing a second card
				to one of the split hands. The second pair will not be split with the current implementation that follows the concept of observation (5).
			(5) Now think a better solution is to add a split_hand = Hand() member to the BlackJackSim class, and use it to play
				the second of the pair of spit hands when a split occurs. And to handle playing out this Hand() within play_game()
				(a) And why not just embed the information for this split hand into the GamePlayOutcome() class, and not mess around with the complicated tuple.

		As of 24-Jan-2024, Observation (5) is what is implemented in the code, and it tests out okay.





	

	
	
